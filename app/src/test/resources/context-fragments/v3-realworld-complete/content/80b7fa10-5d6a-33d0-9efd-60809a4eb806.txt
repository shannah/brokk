I've created the following tasks:
# Task List
1. Annotate `source/blender/bmesh/operators/bmo_dupe.cc` around `void bmo_spin_exec(BMesh *bm, BMOperator *op)` with a brief comment explaining the precision issue (incremental rotation drift) and that the implementation will compute absolute per-step transforms from the original geometry to avoid cumulative floating-point error.
2. Record original vertex mapping and positions upfront: iterate all mesh vertices once, store each vertex's original index in `*((int *)&v->no[0])` (unconditionally, not only when `use_merge`), and allocate an array sized `bm->totvert` to store each original object-space coordinate (e.g., `float (*co_orig)[3] = MEM_malloc_arrayN<float[3]>(bm->totvert, __func__)`). Populate `co_orig[index] = v->co` for all vertices; free this array at the end.
3. Fetch and prepare transform context: read the `space` matrix from the operator input slot, compute its inverse (`invert_m4_m4`), and cache `cent`, normalized `axis`, total `angle`, `steps`, `dvec`. Convert `cent` and all positions/vectors into the `space` coordinate system for computations (positions: apply full 4x4; vectors: apply rotation/scale part with zero translation).
4. Prepare numerically stable rotations: build a unit quaternion `q_total` from `axis` and total `angle`. For each step `i` (0..steps-1), compute the absolute rotation for that step as `q_i = pow_qt_fl_normalized(q_total, (float)(i + 1) / (float)steps)` and convert to a 3x3 (or keep quaternion) to rotate vectors in the `space` coordinate system. This avoids incremental drift.
5. Accumulate screw translation precisely: if `use_dvec`, transform `dvec` into `space` as a vector (ignore translation). Maintain a `double t_accum[3] = {0,0,0}`. On each step `i`, compute `delta_world = R_i * dvec_space` (where `R_i` is the absolute rotation for step i) and add to `t_accum`. This matches the current behavior (rotating `dvec` per step) but accumulates in double precision.
6. Replace per-step incremental rotate/translate with direct coordinate assignment for both branches:
  - After running the duplicate/extrude sub-operator (creating `geom.out`), if not the last step full-revolution merge case, iterate `geom.out` vertices.
  - For each `BMVert *v_new`, read its original index from `*(int *)&v_new->no[0]`, fetch `P0_obj = co_orig[idx]`, compute `P0_space = space * P0_obj` and `P_rot_space = cent_space + R_i * (P0_space - cent_space)`. Then compute `P_space = P_rot_space + (float3)t_accum` (if `use_dvec`). Finally compute `P_obj = space_inv * P_space` and write into `v_new->co`.
  - Remove/bypass the existing `BMO_op_callf` calls for `rotate` and `translate` operating on `geom.out` in both duplicate and extrude branches.
7. Preserve the full-revolution merge behavior (`use_merge`): keep the last-step branch that skips the transform and performs vertex/edge/face splicing. Ensure the original-index propagation from step-0 (stored in `no[0]`) remains, so the merge logic can still resolve `v_dst` via `vtable[idx]`. Do not apply the absolute-position write for the last step when `use_merge && a == steps - 1` to match current topology handling.
8. Add a regression test to catch drift: create a small test that runs `bmo_spin_exec` on a simple mesh (e.g., a single edge or a triangle) with a large number of steps (e.g., 200â€“1000), both with `dvec = 0` and with a non-zero `dvec`. For each intermediate step, compare positions of a representative vertex against the analytical target `cent + R(angle * i/steps) * (P0 - cent) [+ screw translation]` in `space` coordinates, asserting max deviation within a tight epsilon (e.g., 1e-6 to 1e-5 in float).
