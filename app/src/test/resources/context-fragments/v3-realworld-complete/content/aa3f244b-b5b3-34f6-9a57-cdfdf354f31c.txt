diff --git a/source/blender/bmesh/operators/bmo_dupe.cc b/source/blender/bmesh/operators/bmo_dupe.cc
index 5ae18a3..c93a508 100644
--- a/source/blender/bmesh/operators/bmo_dupe.cc
+++ b/source/blender/bmesh/operators/bmo_dupe.cc
@@ -546,30 +546,70 @@
  *
  * Extrude or duplicate geometry a number of times,
  * rotating and possibly translating after each step
+ *
+ * Precision note:
+ * The original implementation applied a fixed incremental rotation (angle/steps) and translation
+ * to the geometry generated by the previous step. This caused floating-point error to accumulate
+ * across steps, leading to visible drift at high step counts.
+ *
+ * This implementation computes absolute transforms per step from the original (step-0) geometry:
+ * - Store each original vertex index and coordinates up-front.
+ * - For step i, compute the absolute rotation R_i for angle * (i + 1) / steps.
+ * - Place new vertices directly using: P_i = cent + R_i * (P0 - cent) + (i + 1) * (R_i * dvec_space),
+ *   transforming positions into and out of the provided 'space' matrix.
+ * - Preserve existing topology creation (duplicate/extrude) and `use_merge` splicing for the last step.
  */
 void bmo_spin_exec(BMesh *bm, BMOperator *op)
 {
   BMOperator dupop, extop;
   float cent[3], dvec[3];
   float axis[3];
-  float rmat[3][3];
-  float phi;
   int steps, do_dupli, a;
   bool use_dvec;
 
+  /* Inputs. */
   BMO_slot_vec_get(op->slots_in, "cent", cent);
   BMO_slot_vec_get(op->slots_in, "axis", axis);
   normalize_v3(axis);
   BMO_slot_vec_get(op->slots_in, "dvec", dvec);
   use_dvec = !is_zero_v3(dvec);
   steps = BMO_slot_int_get(op->slots_in, "steps");
-  phi = BMO_slot_float_get(op->slots_in, "angle") / steps;
+  const float angle_total = BMO_slot_float_get(op->slots_in, "angle");
   do_dupli = BMO_slot_bool_get(op->slots_in, "use_duplicate");
   const bool use_normal_flip = BMO_slot_bool_get(op->slots_in, "use_normal_flip");
   /* Caller needs to perform other sanity checks (such as the spin being 360d). */
   const bool use_merge = BMO_slot_bool_get(op->slots_in, "use_merge") && steps >= 3;
 
-  axis_angle_normalized_to_mat3(rmat, axis, phi);
+  /* Transform context: space and its inverse. */
+  float space[4][4];
+  float space_inv[4][4];
+  BMO_slot_mat4_get(op->slots_in, "space", space);
+  invert_m4_m4(space_inv, space);
+
+  /* Convert center and dvec to 'space' coordinates for stable absolute transforms. */
+  float cent_space[3];
+  copy_v3_v3(cent_space, cent);
+  mul_m4_v3(space, cent_space);
+
+  float space3[3][3];
+  copy_m3_m4(space3, space);
+
+  float dvec_space[3];
+  copy_v3_v3(dvec_space, dvec);
+  mul_m3_v3(space3, dvec_space);
+
+  /* Record original vertex indices and their original object-space coordinates. */
+  float (*co_orig)[3] = MEM_malloc_arrayN<float[3]>(bm->totvert, __func__);
+  {
+    int i = 0;
+    BMIter iter;
+    BMVert *v;
+    BM_ITER_MESH_INDEX (v, &iter, bm, BM_VERTS_OF_MESH, i) {
+      /* Store original index into normal storage so it propagates through duplicate/extrude. */
+      *((int *)&v->no[0]) = i;
+      copy_v3_v3(co_orig[i], v->co);
+    }
+  }
 
   BMVert **vtable = nullptr;
   if (use_merge) {
@@ -579,29 +619,57 @@
     BMVert *v;
     BM_ITER_MESH_INDEX (v, &iter, bm, BM_VERTS_OF_MESH, i) {
       vtable[i] = v;
-      /* Evil! store original index in normal,
-       * this is duplicated into every other vertex.
-       * So we can read the original from the final.
-       *
-       * The normals must be recalculated anyway. */
-      *((int *)&v->no[0]) = i;
+      /* Original indices were written unconditionally above. */
     }
   }
 
   BMO_slot_copy(op, slots_in, "geom", op, slots_out, "geom_last.out");
   for (a = 0; a < steps; a++) {
+    /* Absolute rotation and translation for this step. */
+    const int step_index = a + 1;
+    const float angle_i = angle_total * (float(step_index) / float(steps));
+    float rmat_i[3][3];
+    axis_angle_normalized_to_mat3(rmat_i, axis, angle_i);
+
+    /* Closed-form screw translation: (i + 1) * (R_i * dvec_space). */
+    float t_space[3] = {0.0f, 0.0f, 0.0f};
+    if (use_dvec) {
+      copy_v3_v3(t_space, dvec_space);
+      mul_m3_v3(rmat_i, t_space);
+      mul_v3_fl(t_space, float(step_index));
+    }
+
     if (do_dupli) {
       BMO_op_initf(bm, &dupop, op->flag, "duplicate geom=%S", op, "geom_last.out");
       BMO_op_exec(bm, &dupop);
-      BMO_op_callf(bm,
-                   op->flag,
-                   "rotate cent=%v matrix=%m3 space=%s verts=%S",
-                   cent,
-                   rmat,
-                   op,
-                   "space",
-                   &dupop,
-                   "geom.out");
+
+      /* Reposition new vertices from their original coordinates using absolute transform. */
+      {
+        BMOpSlot *slot_geom_out = BMO_slot_get(dupop.slots_out, "geom.out");
+        BMElem **elem_array = (BMElem **)slot_geom_out->data.buf;
+        const int elem_array_len = slot_geom_out->len;
+        for (int j = 0; j < elem_array_len; j++) {
+          if (elem_array[j]->head.htype == BM_VERT) {
+            BMVert *v_new = (BMVert *)elem_array[j];
+            const int idx = *((const int *)&v_new->no[0]);
+            float p_space[3];
+            copy_v3_v3(p_space, co_orig[idx]);
+            mul_m4_v3(space, p_space);
+
+            float ofs[3];
+            sub_v3_v3v3(ofs, p_space, cent_space);
+            mul_m3_v3(rmat_i, ofs);
+
+            add_v3_v3(ofs, cent_space);
+            add_v3_v3(ofs, t_space);
+
+            /* Back to object space. */
+            mul_m4_v3(space_inv, ofs);
+            copy_v3_v3(v_new->co, ofs);
+          }
+        }
+      }
+
       BMO_slot_copy(&dupop, slots_out, "geom.out", op, slots_out, "geom_last.out");
       BMO_op_finish(bm, &dupop);
     }
@@ -623,15 +691,30 @@
                    true);
       BMO_op_exec(bm, &extop);
       if ((use_merge && (a == steps - 1)) == false) {
-        BMO_op_callf(bm,
-                     op->flag,
-                     "rotate cent=%v matrix=%m3 space=%s verts=%S",
-                     cent,
-                     rmat,
-                     op,
-                     "space",
-                     &extop,
-                     "geom.out");
+        /* Reposition new vertices from their original coordinates using absolute transform. */
+        BMOpSlot *slot_geom_out = BMO_slot_get(extop.slots_out, "geom.out");
+        BMElem **elem_array = (BMElem **)slot_geom_out->data.buf;
+        const int elem_array_len = slot_geom_out->len;
+        for (int j = 0; j < elem_array_len; j++) {
+          if (elem_array[j]->head.htype == BM_VERT) {
+            BMVert *v_new = (BMVert *)elem_array[j];
+            const int idx = *((const int *)&v_new->no[0]);
+            float p_space[3];
+            copy_v3_v3(p_space, co_orig[idx]);
+            mul_m4_v3(space, p_space);
+
+            float ofs[3];
+            sub_v3_v3v3(ofs, p_space, cent_space);
+            mul_m3_v3(rmat_i, ofs);
+
+            add_v3_v3(ofs, cent_space);
+            add_v3_v3(ofs, t_space);
+
+            /* Back to object space. */
+            mul_m4_v3(space_inv, ofs);
+            copy_v3_v3(v_new->co, ofs);
+          }
+        }
         BMO_slot_copy(&extop, slots_out, "geom.out", op, slots_out, "geom_last.out");
       }
       else {
@@ -682,21 +765,12 @@
       }
       BMO_op_finish(bm, &extop);
     }
-
-    if (use_dvec) {
-      mul_m3_v3(rmat, dvec);
-      BMO_op_callf(bm,
-                   op->flag,
-                   "translate vec=%v space=%s verts=%S",
-                   dvec,
-                   op,
-                   "space",
-                   op,
-                   "geom_last.out");
-    }
   }
 
   if (vtable) {
     MEM_freeN(vtable);
   }
+  if (co_orig) {
+    MEM_freeN(co_orig);
+  }
 }
