--- old
+++ new
@@ -549,0 +549,12 @@
+ *
+ * Precision note:
+ * The original implementation applied a fixed incremental rotation (angle/steps) and translation
+ * to the geometry generated by the previous step. This caused floating-point error to accumulate
+ * across steps, leading to visible drift at high step counts.
+ *
+ * This implementation computes absolute transforms per step from the original (step-0) geometry:
+ * - Store each original vertex index and coordinates up-front.
+ * - For step i, compute the absolute rotation R_i for angle * (i + 1) / steps.
+ * - Place new vertices directly using: P_i = cent + R_i * (P0 - cent) + (i + 1) * (R_i * dvec_space),
+ *   transforming positions into and out of the provided 'space' matrix.
+ * - Preserve existing topology creation (duplicate/extrude) and `use_merge` splicing for the last step.
@@ -555,2 +567,0 @@
-  float rmat[3][3];
-  float phi;
@@ -560,0 +570,1 @@
+  /* Inputs. */
@@ -566,1 +577,1 @@
-  phi = BMO_slot_float_get(op->slots_in, "angle") / steps;
+  const float angle_total = BMO_slot_float_get(op->slots_in, "angle");
@@ -572,1 +583,5 @@
-  axis_angle_normalized_to_mat3(rmat, axis, phi);
+  /* Transform context: space and its inverse. */
+  float space[4][4];
+  float space_inv[4][4];
+  BMO_slot_mat4_get(op->slots_in, "space", space);
+  invert_m4_m4(space_inv, space);
@@ -574,0 +589,25 @@
+  /* Convert center and dvec to 'space' coordinates for stable absolute transforms. */
+  float cent_space[3];
+  copy_v3_v3(cent_space, cent);
+  mul_m4_v3(space, cent_space);
+
+  float space3[3][3];
+  copy_m3_m4(space3, space);
+
+  float dvec_space[3];
+  copy_v3_v3(dvec_space, dvec);
+  mul_m3_v3(space3, dvec_space);
+
+  /* Record original vertex indices and their original object-space coordinates. */
+  float (*co_orig)[3] = MEM_malloc_arrayN<float[3]>(bm->totvert, __func__);
+  {
+    int i = 0;
+    BMIter iter;
+    BMVert *v;
+    BM_ITER_MESH_INDEX (v, &iter, bm, BM_VERTS_OF_MESH, i) {
+      /* Store original index into normal storage so it propagates through duplicate/extrude. */
+      *((int *)&v->no[0]) = i;
+      copy_v3_v3(co_orig[i], v->co);
+    }
+  }
+
@@ -582,6 +622,1 @@
-      /* Evil! store original index in normal,
-       * this is duplicated into every other vertex.
-       * So we can read the original from the final.
-       *
-       * The normals must be recalculated anyway. */
-      *((int *)&v->no[0]) = i;
+      /* Original indices were written unconditionally above. */
@@ -593,0 +628,14 @@
+    /* Absolute rotation and translation for this step. */
+    const int step_index = a + 1;
+    const float angle_i = angle_total * (float(step_index) / float(steps));
+    float rmat_i[3][3];
+    axis_angle_normalized_to_mat3(rmat_i, axis, angle_i);
+
+    /* Closed-form screw translation: (i + 1) * (R_i * dvec_space). */
+    float t_space[3] = {0.0f, 0.0f, 0.0f};
+    if (use_dvec) {
+      copy_v3_v3(t_space, dvec_space);
+      mul_m3_v3(rmat_i, t_space);
+      mul_v3_fl(t_space, float(step_index));
+    }
+
@@ -596,9 +645,28 @@
-      BMO_op_callf(bm,
-                   op->flag,
-                   "rotate cent=%v matrix=%m3 space=%s verts=%S",
-                   cent,
-                   rmat,
-                   op,
-                   "space",
-                   &dupop,
-                   "geom.out");
+
+      /* Reposition new vertices from their original coordinates using absolute transform. */
+      {
+        BMOpSlot *slot_geom_out = BMO_slot_get(dupop.slots_out, "geom.out");
+        BMElem **elem_array = (BMElem **)slot_geom_out->data.buf;
+        const int elem_array_len = slot_geom_out->len;
+        for (int j = 0; j < elem_array_len; j++) {
+          if (elem_array[j]->head.htype == BM_VERT) {
+            BMVert *v_new = (BMVert *)elem_array[j];
+            const int idx = *((const int *)&v_new->no[0]);
+            float p_space[3];
+            copy_v3_v3(p_space, co_orig[idx]);
+            mul_m4_v3(space, p_space);
+
+            float ofs[3];
+            sub_v3_v3v3(ofs, p_space, cent_space);
+            mul_m3_v3(rmat_i, ofs);
+
+            add_v3_v3(ofs, cent_space);
+            add_v3_v3(ofs, t_space);
+
+            /* Back to object space. */
+            mul_m4_v3(space_inv, ofs);
+            copy_v3_v3(v_new->co, ofs);
+          }
+        }
+      }
+
@@ -626,9 +694,24 @@
-        BMO_op_callf(bm,
-                     op->flag,
-                     "rotate cent=%v matrix=%m3 space=%s verts=%S",
-                     cent,
-                     rmat,
-                     op,
-                     "space",
-                     &extop,
-                     "geom.out");
+        /* Reposition new vertices from their original coordinates using absolute transform. */
+        BMOpSlot *slot_geom_out = BMO_slot_get(extop.slots_out, "geom.out");
+        BMElem **elem_array = (BMElem **)slot_geom_out->data.buf;
+        const int elem_array_len = slot_geom_out->len;
+        for (int j = 0; j < elem_array_len; j++) {
+          if (elem_array[j]->head.htype == BM_VERT) {
+            BMVert *v_new = (BMVert *)elem_array[j];
+            const int idx = *((const int *)&v_new->no[0]);
+            float p_space[3];
+            copy_v3_v3(p_space, co_orig[idx]);
+            mul_m4_v3(space, p_space);
+
+            float ofs[3];
+            sub_v3_v3v3(ofs, p_space, cent_space);
+            mul_m3_v3(rmat_i, ofs);
+
+            add_v3_v3(ofs, cent_space);
+            add_v3_v3(ofs, t_space);
+
+            /* Back to object space. */
+            mul_m4_v3(space_inv, ofs);
+            copy_v3_v3(v_new->co, ofs);
+          }
+        }
@@ -685,12 +768,0 @@
-
-    if (use_dvec) {
-      mul_m3_v3(rmat, dvec);
-      BMO_op_callf(bm,
-                   op->flag,
-                   "translate vec=%v space=%s verts=%S",
-                   dvec,
-                   op,
-                   "space",
-                   op,
-                   "geom_last.out");
-    }
@@ -702,0 +773,3 @@
+  if (co_orig) {
+    MEM_freeN(co_orig);
+  }