diff --git a/source/blender/bmesh/operators/bmo_dupe.cc b/source/blender/bmesh/operators/bmo_dupe.cc
index 5ae18a3..78197e8 100644
--- a/source/blender/bmesh/operators/bmo_dupe.cc
+++ b/source/blender/bmesh/operators/bmo_dupe.cc
@@ -546,30 +546,70 @@
  *
  * Extrude or duplicate geometry a number of times,
  * rotating and possibly translating after each step
+ *
+ * Precision note:
+ * The original implementation applied a fixed incremental rotation (angle/steps) and translation
+ * to the geometry generated by the previous step. This caused floating-point error to accumulate
+ * across steps, leading to visible drift at high step counts.
+ *
+ * This implementation computes absolute transforms per step from the original (step-0) geometry:
+ * - Store each original vertex index and coordinates up-front.
+ * - For step i, compute the absolute rotation R_i for angle * (i + 1) / steps.
+ * - Place new vertices directly using: P_i = cent + R_i * (P0 - cent) + sum_{k=1..i} (R_k * dvec_space) (accumulated in double precision),
+ *   transforming positions into and out of the provided 'space' matrix.
+ * - Preserve existing topology creation (duplicate/extrude) and `use_merge` splicing for the last step.
  */
 void bmo_spin_exec(BMesh *bm, BMOperator *op)
 {
   BMOperator dupop, extop;
   float cent[3], dvec[3];
   float axis[3];
-  float rmat[3][3];
-  float phi;
   int steps, do_dupli, a;
   bool use_dvec;
 
+  /* Inputs. */
   BMO_slot_vec_get(op->slots_in, "cent", cent);
   BMO_slot_vec_get(op->slots_in, "axis", axis);
   normalize_v3(axis);
   BMO_slot_vec_get(op->slots_in, "dvec", dvec);
   use_dvec = !is_zero_v3(dvec);
   steps = BMO_slot_int_get(op->slots_in, "steps");
-  phi = BMO_slot_float_get(op->slots_in, "angle") / steps;
+  const float angle_total = BMO_slot_float_get(op->slots_in, "angle");
   do_dupli = BMO_slot_bool_get(op->slots_in, "use_duplicate");
   const bool use_normal_flip = BMO_slot_bool_get(op->slots_in, "use_normal_flip");
   /* Caller needs to perform other sanity checks (such as the spin being 360d). */
   const bool use_merge = BMO_slot_bool_get(op->slots_in, "use_merge") && steps >= 3;
 
-  axis_angle_normalized_to_mat3(rmat, axis, phi);
+  /* Transform context: space and its inverse. */
+  float space[4][4];
+  float space_inv[4][4];
+  BMO_slot_mat4_get(op->slots_in, "space", space);
+  invert_m4_m4(space_inv, space);
+
+  /* Convert center and dvec to 'space' coordinates for stable absolute transforms. */
+  float cent_space[3];
+  copy_v3_v3(cent_space, cent);
+  mul_m4_v3(space, cent_space);
+
+  float space3[3][3];
+  copy_m3_m4(space3, space);
+
+  float dvec_space[3];
+  copy_v3_v3(dvec_space, dvec);
+  mul_m3_v3(space3, dvec_space);
+
+  /* Record original vertex indices and their original object-space coordinates. */
+  float (*co_orig)[3] = MEM_malloc_arrayN<float[3]>(bm->totvert, __func__);
+  {
+    int i = 0;
+    BMIter iter;
+    BMVert *v;
+    BM_ITER_MESH_INDEX (v, &iter, bm, BM_VERTS_OF_MESH, i) {
+      /* Store original index into normal storage so it propagates through duplicate/extrude. */
+      *((int *)&v->no[0]) = i;
+      copy_v3_v3(co_orig[i], v->co);
+    }
+  }
 
   BMVert **vtable = nullptr;
   if (use_merge) {
@@ -579,29 +619,65 @@
     BMVert *v;
     BM_ITER_MESH_INDEX (v, &iter, bm, BM_VERTS_OF_MESH, i) {
       vtable[i] = v;
-      /* Evil! store original index in normal,
-       * this is duplicated into every other vertex.
-       * So we can read the original from the final.
-       *
-       * The normals must be recalculated anyway. */
-      *((int *)&v->no[0]) = i;
+      /* Original indices were written unconditionally above. */
     }
   }
 
   BMO_slot_copy(op, slots_in, "geom", op, slots_out, "geom_last.out");
+  /* Accumulate screw translation in double precision across steps. */
+  double t_accum[3] = {0.0, 0.0, 0.0};
   for (a = 0; a < steps; a++) {
+    /* Absolute rotation and translation for this step. */
+    const int step_index = a + 1;
+    const float angle_i = angle_total * (float(step_index) / float(steps));
+    float rmat_i[3][3];
+    axis_angle_normalized_to_mat3(rmat_i, axis, angle_i);
+
+    /* Accumulate screw translation precisely as sum_{k=1..step_index} (R_k * dvec_space) using double precision. */
+    float t_space[3] = {0.0f, 0.0f, 0.0f};
+    if (use_dvec) {
+      float delta_space[3];
+      copy_v3_v3(delta_space, dvec_space);
+      mul_m3_v3(rmat_i, delta_space);
+      t_accum[0] += (double)delta_space[0];
+      t_accum[1] += (double)delta_space[1];
+      t_accum[2] += (double)delta_space[2];
+      t_space[0] = (float)t_accum[0];
+      t_space[1] = (float)t_accum[1];
+      t_space[2] = (float)t_accum[2];
+    }
+
     if (do_dupli) {
       BMO_op_initf(bm, &dupop, op->flag, "duplicate geom=%S", op, "geom_last.out");
       BMO_op_exec(bm, &dupop);
-      BMO_op_callf(bm,
-                   op->flag,
-                   "rotate cent=%v matrix=%m3 space=%s verts=%S",
-                   cent,
-                   rmat,
-                   op,
-                   "space",
-                   &dupop,
-                   "geom.out");
+
+      /* Reposition new vertices from their original coordinates using absolute transform. */
+      {
+        BMOpSlot *slot_geom_out = BMO_slot_get(dupop.slots_out, "geom.out");
+        BMElem **elem_array = (BMElem **)slot_geom_out->data.buf;
+        const int elem_array_len = slot_geom_out->len;
+        for (int j = 0; j < elem_array_len; j++) {
+          if (elem_array[j]->head.htype == BM_VERT) {
+            BMVert *v_new = (BMVert *)elem_array[j];
+            const int idx = *((const int *)&v_new->no[0]);
+            float p_space[3];
+            copy_v3_v3(p_space, co_orig[idx]);
+            mul_m4_v3(space, p_space);
+
+            float ofs[3];
+            sub_v3_v3v3(ofs, p_space, cent_space);
+            mul_m3_v3(rmat_i, ofs);
+
+            add_v3_v3(ofs, cent_space);
+            add_v3_v3(ofs, t_space);
+
+            /* Back to object space. */
+            mul_m4_v3(space_inv, ofs);
+            copy_v3_v3(v_new->co, ofs);
+          }
+        }
+      }
+
       BMO_slot_copy(&dupop, slots_out, "geom.out", op, slots_out, "geom_last.out");
       BMO_op_finish(bm, &dupop);
     }
@@ -623,15 +699,30 @@
                    true);
       BMO_op_exec(bm, &extop);
       if ((use_merge && (a == steps - 1)) == false) {
-        BMO_op_callf(bm,
-                     op->flag,
-                     "rotate cent=%v matrix=%m3 space=%s verts=%S",
-                     cent,
-                     rmat,
-                     op,
-                     "space",
-                     &extop,
-                     "geom.out");
+        /* Reposition new vertices from their original coordinates using absolute transform. */
+        BMOpSlot *slot_geom_out = BMO_slot_get(extop.slots_out, "geom.out");
+        BMElem **elem_array = (BMElem **)slot_geom_out->data.buf;
+        const int elem_array_len = slot_geom_out->len;
+        for (int j = 0; j < elem_array_len; j++) {
+          if (elem_array[j]->head.htype == BM_VERT) {
+            BMVert *v_new = (BMVert *)elem_array[j];
+            const int idx = *((const int *)&v_new->no[0]);
+            float p_space[3];
+            copy_v3_v3(p_space, co_orig[idx]);
+            mul_m4_v3(space, p_space);
+
+            float ofs[3];
+            sub_v3_v3v3(ofs, p_space, cent_space);
+            mul_m3_v3(rmat_i, ofs);
+
+            add_v3_v3(ofs, cent_space);
+            add_v3_v3(ofs, t_space);
+
+            /* Back to object space. */
+            mul_m4_v3(space_inv, ofs);
+            copy_v3_v3(v_new->co, ofs);
+          }
+        }
         BMO_slot_copy(&extop, slots_out, "geom.out", op, slots_out, "geom_last.out");
       }
       else {
@@ -682,21 +773,12 @@
       }
       BMO_op_finish(bm, &extop);
     }
-
-    if (use_dvec) {
-      mul_m3_v3(rmat, dvec);
-      BMO_op_callf(bm,
-                   op->flag,
-                   "translate vec=%v space=%s verts=%S",
-                   dvec,
-                   op,
-                   "space",
-                   op,
-                   "geom_last.out");
-    }
   }
 
   if (vtable) {
     MEM_freeN(vtable);
   }
+  if (co_orig) {
+    MEM_freeN(co_orig);
+  }
 }
diff --git a/source/blender/bmesh/tests/test_bmo_spin_precision.cc b/source/blender/bmesh/tests/test_bmo_spin_precision.cc
new file mode 100644
index 0000000..9f75bf3
--- /dev/null
+++ b/source/blender/bmesh/tests/test_bmo_spin_precision.cc
@@ -0,0 +1,307 @@
+/* SPDX-FileCopyrightText: 2025 Blender Authors
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later */
+
+#include "testing/testing.h"
+
+#include <algorithm>
+#include <array>
+#include <cmath>
+#include <unordered_set>
+#include <vector>
+
+#include "BLI_math_matrix.h"
+#include "BLI_math_rotation.h"
+#include "BLI_math_vector.h"
+
+#include "bmesh.hh"
+
+/* Helpers */
+
+static void axis_angle_rmat_3x3(float rmat[3][3], const float axis[3], float angle)
+{
+  float naxis[3];
+  copy_v3_v3(naxis, axis);
+  normalize_v3(naxis);
+  axis_angle_normalized_to_mat3(rmat, naxis, angle);
+}
+
+/* Compute angle in [0, 2*pi) of (co - cent) around given axis.
+ * For the test axis=(0,0,1) & cent=(0,0,0), this reduces to atan2(y, x).
+ * Implemented generically by projecting onto the plane orthogonal to axis. */
+static float angle_around_axis(const float cent[3], const float axis[3], const float co[3])
+{
+  float v[3];
+  sub_v3_v3v3(v, co, cent);
+
+  /* Build orthonormal basis (u, v, w=axis). */
+  float w[3];
+  copy_v3_v3(w, axis);
+  normalize_v3(w);
+
+  float u[3], tmp[3] = {1.0f, 0.0f, 0.0f};
+  if (fabsf(dot_v3v3(w, tmp)) > 0.99f) {
+    copy_v3_fl3(tmp, 0.0f, 1.0f, 0.0f);
+  }
+  cross_v3_v3v3(u, w, tmp);
+  normalize_v3(u);
+  float vv[3];
+  cross_v3_v3v3(vv, w, u);
+
+  /* Coordinates in the plane: (x=u·v, y=vv·v). */
+  float x = dot_v3v3(u, v);
+  float y = dot_v3v3(vv, v);
+  float a = atan2f(y, x);
+  if (a < 0.0f) {
+    a += 2.0f * float(M_PI);
+  }
+  return a;
+}
+
+static void compute_expected_position(const float r_i[3][3],
+                                      const float cent[3],
+                                      const float p0[3],
+                                      const float t_space[3],
+                                      float r_out[3])
+{
+  float d[3];
+  sub_v3_v3v3(d, p0, cent);
+  float rr[3];
+  copy_v3_v3(rr, d);
+  mul_m3_v3((float(*)[3])r_i, rr);
+  add_v3_v3(rr, cent);
+  add_v3_v3(rr, t_space);
+  copy_v3_v3(r_out, rr);
+}
+
+/* Accumulate screw translation t_accum += R_i * dvec_space for step 'step_index' (1..steps).
+ * Returns t_space_out = float3(t_accum). */
+static void accumulate_screw_translation(const int step_index,
+                                         const int steps,
+                                         const float angle_total,
+                                         const float axis[3],
+                                         const float dvec_space[3],
+                                         double t_accum[3],
+                                         float t_space_out[3])
+{
+  float angle_i = angle_total * (float(step_index) / float(steps));
+  float rmat_i[3][3];
+  axis_angle_rmat_3x3(rmat_i, axis, angle_i);
+  float delta[3];
+  copy_v3_v3(delta, dvec_space);
+  mul_m3_v3(rmat_i, delta);
+  t_accum[0] += double(delta[0]);
+  t_accum[1] += double(delta[1]);
+  t_accum[2] += double(delta[2]);
+  t_space_out[0] = float(t_accum[0]);
+  t_space_out[1] = float(t_accum[1]);
+  t_space_out[2] = float(t_accum[2]);
+}
+
+/* Build a minimal mesh: two verts along +X and a single edge. */
+static void build_single_edge_mesh(BMesh *bm, BMVert **r_v0, BMVert **r_v1, BMEdge **r_e01)
+{
+  const float co0[3] = {1.0f, 0.0f, 0.0f};
+  const float co1[3] = {2.0f, 0.0f, 0.0f};
+  BMVert *v0 = BM_vert_create(bm, co0, nullptr, BM_CREATE_NOP);
+  BMVert *v1 = BM_vert_create(bm, co1, nullptr, BM_CREATE_NOP);
+  BMEdge *e01 = BM_edge_create(bm, v0, v1, nullptr, BM_CREATE_NOP);
+  *r_v0 = v0;
+  *r_v1 = v1;
+  *r_e01 = e01;
+}
+
+/* Return true if vertex 'v' is in 'orig' set. */
+static bool is_original_vert(const std::unordered_set<const BMVert *> &orig, const BMVert *v)
+{
+  return orig.find(v) != orig.end();
+}
+
+static void run_spin_precision_test(int steps, const float angle_total, const float dvec_in[3], float epsilon)
+{
+  BMeshCreateParams params{};
+  params.use_toolflags = true;
+  BMesh *bm = BM_mesh_create(&bm_mesh_allocsize_default, &params);
+
+  BMVert *v0, *v1;
+  BMEdge *e01;
+  build_single_edge_mesh(bm, &v0, &v1, &e01);
+
+  /* Keep originals for filtering. */
+  std::unordered_set<const BMVert *> orig_verts;
+  orig_verts.insert(v0);
+  orig_verts.insert(v1);
+
+  /* Save original coordinates by index after the operator writes indices into v->no. */
+  /* We do not know indices yet, but bmo_spin_exec writes them into v->no at entry,
+   * so we can rely on that for mapping newly created vertices to their originals. */
+
+  /* Prepare operator. */
+  BMOperator op;
+  BMO_op_init(bm, &op, 0, "spin");
+
+  /* Input geometry: pass both verts and the edge. */
+  {
+    BMElem *elems[3];
+    elems[0] = (BMElem *)v0;
+    elems[1] = (BMElem *)v1;
+    elems[2] = (BMElem *)e01;
+    BMO_slot_buffer_from_array(bm, &op, "geom", BM_ALL_NOLOOP, (void **)elems, 3);
+  }
+
+  /* Parameters. */
+  const float cent[3] = {0.0f, 0.0f, 0.0f};
+  const float axis[3] = {0.0f, 0.0f, 1.0f};
+  float dvec[3] = {dvec_in[0], dvec_in[1], dvec_in[2]};
+  float space[4][4];
+  unit_m4(space);
+
+  BMO_slot_vec_set(op.slots_in, "cent", (const float *)cent);
+  BMO_slot_vec_set(op.slots_in, "axis", (const float *)axis);
+  BMO_slot_vec_set(op.slots_in, "dvec", (const float *)dvec);
+  BMO_slot_int_set(op.slots_in, "steps", steps);
+  BMO_slot_float_set(op.slots_in, "angle", angle_total);
+  BMO_slot_mat4_set(op.slots_in, "space", space);
+  BMO_slot_bool_set(op.slots_in, "use_duplicate", true);
+  BMO_slot_bool_set(op.slots_in, "use_merge", false);
+  BMO_slot_bool_set(op.slots_in, "use_normal_flip", false);
+
+  /* Execute. */
+  BMO_op_exec(bm, &op);
+
+  /* Record original positions by the indices stored in 'no'. */
+  /* Build a mapping orig_idx -> P0 (co_orig). */
+  std::vector<std::array<float, 3>> co_orig_vec; /* We'll emulate float3 as array below. */
+  {
+    int i = 0;
+    BMIter iter;
+    BMVert *v;
+#if 1
+    /* First pass: find max index so we can size co_orig_vec. */
+    int max_idx = -1;
+    BM_ITER_MESH (v, &iter, bm, BM_VERTS_OF_MESH) {
+      if (is_original_vert(orig_verts, v)) {
+        /* bmo_spin_exec writes index to v->no, fetch it. */
+        int idx = *((const int *)&v->no[0]);
+        if (idx > max_idx) {
+          max_idx = idx;
+        }
+      }
+    }
+    co_orig_vec.resize(max_idx + 1);
+    /* Fill co_orig by iterating originals again. */
+    BM_ITER_MESH (v, &iter, bm, BM_VERTS_OF_MESH) {
+      if (is_original_vert(orig_verts, v)) {
+        int idx = *((const int *)&v->no[0]);
+        co_orig_vec[idx] = {v->co[0], v->co[1], v->co[2]};
+      }
+    }
+#else
+    (void)i;
+#endif
+  }
+
+  /* Gather new vertices by original index. */
+  std::vector<BMVert *> clones_by_idx0;
+  std::vector<BMVert *> clones_by_idx1;
+  {
+    BMIter iter;
+    BMVert *v;
+    BM_ITER_MESH (v, &iter, bm, BM_VERTS_OF_MESH) {
+      if (is_original_vert(orig_verts, v)) {
+        continue;
+      }
+      int idx = *((const int *)&v->no[0]);
+      if (idx == 0) {
+        clones_by_idx0.push_back(v);
+      }
+      else if (idx == 1) {
+        clones_by_idx1.push_back(v);
+      }
+    }
+  }
+
+  /* Sanity: we expect exactly 'steps' clones for each original vertex. */
+  EXPECT_EQ((int)clones_by_idx0.size(), steps);
+  EXPECT_EQ((int)clones_by_idx1.size(), steps);
+
+  /* Sort clones by measured angle so j-th vertex corresponds to step index i=j+1. */
+  auto angle_cmp = [&](BMVert *a, BMVert *b) {
+    float aa = angle_around_axis(cent, axis, a->co);
+    float bb = angle_around_axis(cent, axis, b->co);
+    return aa < bb;
+  };
+  std::sort(clones_by_idx0.begin(), clones_by_idx0.end(), angle_cmp);
+  std::sort(clones_by_idx1.begin(), clones_by_idx1.end(), angle_cmp);
+
+  /* Validate per-step positions for one representative original (idx 0). */
+  {
+    const float p0[3] = {co_orig_vec[0][0], co_orig_vec[0][1], co_orig_vec[0][2]};
+    double t_accum[3] = {0.0, 0.0, 0.0};
+    for (int i = 1; i <= steps; i++) {
+      BMVert *v = clones_by_idx0[i - 1];
+
+      float r_i[3][3];
+      axis_angle_rmat_3x3(r_i, axis, angle_total * (float(i) / float(steps)));
+
+      float t_space[3] = {0, 0, 0};
+      if (!is_zero_v3(dvec)) {
+        accumulate_screw_translation(i, steps, angle_total, axis, dvec, t_accum, t_space);
+      }
+
+      float target[3];
+      compute_expected_position(r_i, cent, p0, t_space, target);
+
+      float diff[3];
+      sub_v3_v3v3(diff, v->co, target);
+      float max_abs = std::max(std::fabs(diff[0]), std::max(std::fabs(diff[1]), std::fabs(diff[2])));
+      ASSERT_LE(max_abs, epsilon) << "Step " << i << " deviation too high for orig idx 0";
+    }
+  }
+
+  /* Optionally, validate for the second original as well. */
+  {
+    const float p0[3] = {co_orig_vec[1][0], co_orig_vec[1][1], co_orig_vec[1][2]};
+    double t_accum[3] = {0.0, 0.0, 0.0};
+    for (int i = 1; i <= steps; i++) {
+      BMVert *v = clones_by_idx1[i - 1];
+
+      float r_i[3][3];
+      axis_angle_rmat_3x3(r_i, axis, angle_total * (float(i) / float(steps)));
+
+      float t_space[3] = {0, 0, 0};
+      if (!is_zero_v3(dvec)) {
+        accumulate_screw_translation(i, steps, angle_total, axis, dvec, t_accum, t_space);
+      }
+
+      float target[3];
+      compute_expected_position(r_i, cent, p0, t_space, target);
+
+      float diff[3];
+      sub_v3_v3v3(diff, v->co, target);
+      float max_abs = std::max(std::fabs(diff[0]), std::max(std::fabs(diff[1]), std::fabs(diff[2])));
+      ASSERT_LE(max_abs, epsilon) << "Step " << i << " deviation too high for orig idx 1";
+    }
+  }
+
+  BMO_op_finish(bm, &op);
+  BM_mesh_free(bm);
+}
+
+/* Tests */
+
+TEST(BMesh, SpinPrecision_PureRotation)
+{
+  const float angle_total = 1.2345f;
+  const float dvec[3] = {0.0f, 0.0f, 0.0f};
+  run_spin_precision_test(200, angle_total, dvec, 1.0e-6f);
+  run_spin_precision_test(800, angle_total, dvec, 1.0e-6f);
+}
+
+TEST(BMesh, SpinPrecision_Screw)
+{
+  const float angle_total = 1.2345f;
+  const float dvec[3] = {0.01f, 0.02f, 0.003f};
+  run_spin_precision_test(200, angle_total, dvec, 1.0e-5f);
+  run_spin_precision_test(800, angle_total, dvec, 1.0e-5f);
+}
