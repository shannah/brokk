<!DOCTYPE html>
<html class="theme-light">
<head>
    <meta charset="utf-8">
    <title>Brokk MOP - Dev Mode</title>
</head>
<style>
    #mop-root {
        top: 550px !important;
    }

    #dev-tools {
        margin: 1em;
    }

    /* Zoom Widget styles are now in global.scss */
</style>
<body>
<div id="dev-tools">
    <h1>Brokk MOP - Development Mode</h1>
    <p>Events from Java will be logged to the console and displayed raw below.</p>
    <h3>Dev Tools</h3>
    <button onclick="streamAsk()">Stream "Ask"</button>
    <button onclick="streamEdit()">Stream "Edit"</button>
    <button onclick="showAskMd()">Show "ask" MD</button>
    <button onclick="showEditMd()">Show "edit" MD</button>
    <button onclick="window.brokk.setTheme(!document.querySelector('html').classList.contains('theme-dark'))">Toggle
        Theme
    </button>
    <button onclick="window.brokk.clear()">Clear Log</button>
    <button onclick="window.brokk.showSpinner('Testing spinner...'); window.brokk.hideSpinner">
        Test Spinner
    </button>
    <button onclick="window.brokk.hideSpinner()">Hide Spinner</button>
    <button id="toggle-wrap-btn" onclick="toggleCodeWrap()">Toggle Code Wrap</button>
    <span id="wrap-mode-status" style="margin-left:6px; color:#666;">(scroll)</span>
    <br>
    <button onclick="window.brokk.setTheme(false, false, true)">Test Java SetTheme (Light + Wrap)</button>
    <button onclick="window.brokk.setTheme(true, false, false)">Test Java SetTheme (Dark + Scroll)</button>
    <button onclick="showAllCodeblockCases()">Show All Code Block Cases</button>
    <h3>Search Tools</h3>
    <input type="text" id="search-query-input" placeholder="Search query" style="width: 200px; margin-right: 5px;">
    <label><input type="checkbox" id="search-case-sensitive"> Case Sensitive</label>
    <button onclick="setSearchFromInput()">Set Search</button>
    <button onclick="window.brokk.clearSearch()">Clear Search</button>
    <button onclick="window.brokk.nextMatch()">Next Match</button>
    <button onclick="window.brokk.prevMatch()">Prev Match</button>
    <button onclick="window.brokk.scrollToCurrent()">Scroll To Current</button>
    <p>Search State: <span id="search-state-display">N/A</span></p>

    <h3>Symbol Lookup Testing</h3>
    <div id="symbol-test-controls">
        <button onclick="showSymbolTestContent()">Load Test Content</button>
        <button onclick="streamSymbolTestContent()">Stream Symbol Test Content</button>
        <button onclick="showPartialMatchTest()">üÜï Test Partial Matches</button>
        <button onclick="listMockSymbols()">List Mock Database</button>
    </div>
    <div id="symbol-status" style="margin: 10px 0; font-family: monospace; font-size: 12px; color: #666;">
        Mock Symbol Database: <span id="symbol-count">0</span> symbols loaded
    </div>

    <textarea id="md-playground"
              placeholder="Type Markdown here... Try: `List` vs `List.add` to test partial matches!"
              style="width:100%;height:150px;margin:1em 0;box-sizing:border-box;"></textarea>

</div>

<script>
    // Immediately define brokk with a buffer to catch early events and calls from Java
    (function () {
        const buffer = []; // Unified buffer for all calls and events
        let seq = 0; // Sequence number to maintain order

        window.brokk = new Proxy({
            _buffer: buffer
        }, {
            get(target, prop) {
                if (prop === '_buffer') {
                    return target[prop];
                }
                return (...args) => {
                    if (prop === 'onEvent') {
                        console.log('Buffering early event from Java:', JSON.stringify(args));
                        buffer.push({type: 'event', payload: args[0], seq: seq++});
                    } else if (prop === 'hideSpinner') {
                        console.log('Buffering early call from Java to', prop);
                        buffer.push({type: 'call', method: prop, args: [], seq: seq++});
                    } else {
                        console.log('Buffering early call from Java to', prop);
                        buffer.push({type: 'call', method: prop, args: args, seq: seq++});
                    }
                    return undefined;
                };
            }
        });
    })();
</script>

<script type="module">
    // Import and initialize mock Java bridge for dev mode
    import { createMockJavaBridge } from '/src/dev/mockJavaBridge.ts';
    window.javaBridge = createMockJavaBridge();
</script>

<script type="module" src="/src/index.ts"></script>

<script>
    function simulateEvent(type, data = {}) {
        window.brokk.onEvent({type, epoch: Date.now(), ...data});
    }


    const contentUser = `> "npm run dev" should run vite/svelte based on dev.html? \nany idea?`;
    const contentAi = `

### Here some code you need to load dynamically
  \`\`\`css
      /* Basic styling for a button */
    .button-primary {
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .button-primary:hover {
      background-color: #0056b3;
    }
  \`\`\`

  \`\`\`csharp
  using System;

    public class Person
    {
        public string Name { get; }
        public int Age { get; }

        public Person(string name, int age)
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            Age = age;
        }

        public void Greet()
        {
            Console.WriteLine($"Hello, my name is {Name} and I'm {Age} years old.");
        }
    }

    class Program
    {
        static void Main()
        {
            var person = new Person("Alice", 30);
            person.Greet();
        }
    }
  \`\`\`

### Why Vite is showing *index.html* even though you have *dev.html*

1. **Vite‚Äôs default entry point**
   When you execute \`vite\` (or \`vite --port 5173\`) the dev-server looks in the project root for \`index.html\`.
   Any other HTML files (e.g. \`dev.html\`) are still reachable at \`http://localhost:5173/dev.html\`, but the page that Vite *automatically* opens in the browser (or shows when you visit the bare root \`/\`) is always \`index.html\` unless you change either:
   - the **root directory**, or
   - the **page that the browser is told to open**.

  \`\`\`java
  @Tool("Create a GitHub pull-request for the current branch. "
          + "If title or body is blank they are auto-generated. "
          + "This implicitly pushes the branch and sets upstream when needed.")
    public String createPullRequest(
            @Nullable @P("PR title (optional)")  String title,
    @Nullable @P("PR description in Markdown (optional)") String body)
    {
      var cursor = messageCursor();
      io.llmOutput("Creating pull request‚Ä¶", ChatMessageType.CUSTOM, true);

      try {
        var project = contextManager.getProject();
        if (!project.hasGit())
          throw new IllegalStateException("Not a Git repository");

        var repo          = (GitRepo) project.getRepo();
        var defaultBranch = repo.getDefaultBranch()
                .orElseThrow(() -> new IllegalStateException("Cannot determine default branch"));
        var currentBranch = repo.getCurrentBranch();
        if (Objects.equals(currentBranch, defaultBranch))
          throw new IllegalStateException("Refusing to open PR from default branch (" + defaultBranch + ')');

        if (!repo.getModifiedFiles().isEmpty())
          throw new IllegalStateException("Uncommitted changes present; commit first");

        var gws = new GitWorkflowService(contextManager);

        // Auto-generate title/body if blank
        if (title == null || title.isBlank() || body == null || body.isBlank()) {
          var suggestion = gws.suggestPullRequestDetails(currentBranch, defaultBranch, io);
          if (title == null || title.isBlank()) title = suggestion.title();
          if (body  == null || body.isBlank())  body  = suggestion.description();
        }

        var prUrl = gws.createPullRequest(currentBranch, defaultBranch, title.trim(), body.trim());
        var msg   = "Opened PR: " + prUrl;
        io.llmOutput(msg, ChatMessageType.CUSTOM);
        logger.info(msg);

        // Persist result to history
        var newMessages = messagesSince(cursor);
        contextManager.addToHistory(new TaskResult(contextManager,
                        "Git create PR",
                        newMessages,
                        Set.of(),
                        TaskResult.StopReason.SUCCESS),
                false);
        return msg;
      } catch (Exception e) {
      var err = "Create PR failed: " + e.getMessage();
      io.llmOutput(err, ChatMessageType.CUSTOM);
      logger.error(err, e);

      var newMessages = messagesSince(cursor);
      contextManager.addToHistory(new TaskResult(contextManager,
                      "Git create PR",
                      newMessages,
                      Set.of(),
                      TaskResult.StopReason.TOOL_ERROR),
              false);
      throw new RuntimeException(err, e);
    }
    }
  \`\`\`

2. **Where your files live**
   Your tree is:

   \`\`\`
   frontend-mop/
     dev.html          ‚Üê dev-only page
     index.html        ‚Üê production entry
     vite.config.mjs
     src/
   \`\`\`

   That means:
   - Production build (\`vite build\`) will read *index.html* (because that is Vite convention when \`root\` is the repo root).
   - Dev server (\`vite\`) will also treat *index.html* as the ‚Äúhome page‚Äù, while *dev.html* is reachable as a secondary route.

---

### Options to make \`npm run dev\` ‚Äústart with‚Äù \`dev.html\`

| Option | What you change | Pros | Cons |
|--------|-----------------|------|------|
| 1. Add a query to the \`open\` option | vite.config.mjs<br>\`server: { open: '/dev.html' }\` | Zero CLI changes; auto-opens correct page | Still serves \`index.html\` at \`/\`; not ideal if you *never* want \`index.html\` in dev |
| 2. Modify the npm script | \`"dev": "vite --open /dev.html"\` | No config file edits | Same caveat as above |
| 3. Point the dev server at a different **root** | Create \`frontend-mop/dev/\` and move/rename files so *dev.html* becomes \`dev/index.html\` and set \`root: 'dev'\` just for the dev command (e.g. with a second Vite config) | Clean separation of dev vs prod HTML | Requires file moves or a second config file |
| 4. Symlink or rename | Temporarily rename \`dev.html\` ‚Üí \`index.html\` when in dev (via a pre-dev script) | Works with zero Vite tweaks | Adds build-step complexity / brittle |

### Minimal, lowest-friction fix

Add a small dev-only section to \`vite.config.mjs\`:

\`\`\`js
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

export default defineConfig(({ command }) => ({
  plugins: [svelte()],
  build: {
    outDir: '../src/main/resources/mop-web',
    emptyOutDir: true
  },
  // Only for \`vite dev\`
  server: {
    port: 5173,
    // Open /dev.html instead of /
    open: command === 'serve' ? '/dev.html' : undefined
  }
}))
\`\`\`

Or if you prefer not to touch \`vite.config.mjs\`, simply update the npm script:

\`\`\`json
"scripts": {
  "dev": "vite --port 5173 --open /dev.html",
  ...
}
\`\`\`

Both approaches:

1. Keep production build logic intact (still builds from \`index.html\`).
2. Automatically open \`http://localhost:5173/dev.html\` whenever you run \`npm run dev\`.
3. Still allow visiting \`index.html\` by typing the full URL if ever needed.

### Key takeaway

- Vite always *serves* every HTML file under \`root\`, but it *opens* only one page at start-up.
- Adjusting \`server.open\` (or the CLI \`--open\`) lets you point dev mode to whichever HTML file you want without disturbing the production build.
`;

    function streamAsk() {
        let index = 0;

        const chunks = contentAi.match(/[\s\S]{1,10}/g) || [];
        const interval = setInterval(() => {
            if (index < chunks.length) {
                simulateEvent('chunk', {text: chunks[index], msgType: 'AI', streaming: true, reasoning: false});
                index++;
            } else {
                clearInterval(interval);
                simulateEvent('chunk', {text: "Ask command complete!", msgType: 'CUSTOM', streaming: true, isNew: false, reasoning: false});
            }
        }, 10);
    }

    function showAskMd() {
        simulateEvent('history-task', {compressed: false, summary: "", messages: [{msgType: 'USER', text: contentUser}, {msgType: 'AI', text: contentAi}]})
        simulateEvent('history-task', {compressed: false, summary: "", messages: [{msgType: 'USER', text: "Implement the changes like described"}, {msgType: 'AI', text: ai}]})
        simulateEvent('chunk', {text: contentUser, msgType: 'USER', streaming: false, reasoning: false})
        simulateEvent('chunk', {text: "Just a little bit of reasoning...\nNow I am finished!", msgType: 'AI', streaming: false, reasoning: true})
        simulateEvent('chunk', {text: contentAi, msgType: 'AI', streaming: false, reasoning: false})
        simulateEvent('chunk', {text: "# Now we are finished!", msgType: 'CUSTOM', streaming: false, reasoning: false})
    }


    const ai = `

  Looking at the failed blocks and the current content, I can see the issue. The file is in a broken state where it references \`commitBrowserPanel\` (which doesn't exist) but we need to revert those changes back to use the original table model code.

  Let me fix the specific lines that are causing the build failure:

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.unknown
          // ============ Commit Browser Panel (center ~80%) ============
          commitBrowserPanel = new GitCommitBrowserPanel(chrome, contextManager);
          JPanel commitBrowserContainer = buildCommitBrowserContainer();
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
          // ============ Commit Browser Panel (center ~80%) ============
          JPanel commitBrowserPanel = buildCommitBrowserPanel();
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
          constraints.gridx = 1; // commit browser (commits + changes)
          constraints.weightx = 0.80;
          logPanel.add(commitBrowserContainer, constraints);
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
          constraints.gridx = 1; // commit browser (commits + changes)
          constraints.weightx = 0.80;
          logPanel.add(commitBrowserPanel, constraints);
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
                          logger.warn("Could not select any local branch (target: {}, current git: {}). Clearing commits.",
                                      previouslySelectedBranch, currentGitBranch);
                          commitBrowserPanel.setCommits(List.of());
                          pullButton.setEnabled(false);
                          pushButton.setEnabled(false);
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
                          logger.warn("Could not select any local branch (target: {}, current git: {}). Clearing commits.",
                                      previouslySelectedBranch, currentGitBranch);
                          commitsTableModel.setRowCount(0);
                          changesRootNode.removeAllChildren();
                          changesTreeModel.reload();
                          revisionTextLabel.setText("Revision:");
                          revisionIdTextArea.setText("N/A");
                          pullButton.setEnabled(false);
                          pushButton.setEnabled(false);
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
                  SwingUtilities.invokeLater(() -> {
                      branchTableModel.setRowCount(0);
                      branchTableModel.addRow(new Object[]{"", "Error fetching branches: " + e.getMessage()});
                      remoteBranchTableModel.setRowCount(0);
                      commitBrowserPanel.setCommits(List.of());
                  });
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
                  SwingUtilities.invokeLater(() -> {
                      branchTableModel.setRowCount(0);
                      branchTableModel.addRow(new Object[]{"", "Error fetching branches: " + e.getMessage()});
                      remoteBranchTableModel.setRowCount(0);
                      commitsTableModel.setRowCount(0);
                      changesRootNode.removeAllChildren();
                      changesTreeModel.reload();
                      revisionTextLabel.setText("Revision:");
                      revisionIdTextArea.setText("N/A");
                  });
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
                      if (finalCommits.isEmpty()) {
                          commitBrowserPanel.setCommits(List.of());
                          return;
                      }

                      commitBrowserPanel.setCommits(finalCommits);
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
                      if (commitRows.isEmpty()) {
                          revisionTextLabel.setText("Revision:");
                          revisionIdTextArea.setText("N/A");
                          return;
                      }

                      for (Object[] rowData : commitRows) {
                          commitsTableModel.addRow(rowData);
                      }

                      // Fit column widths for author and date
                      TableUtils.fitColumnWidth(commitsTable, 1); // Author column
                      TableUtils.fitColumnWidth(commitsTable, 2); // Date column

                      if (commitsTableModel.getRowCount() > 0) {
                          commitsTable.setRowSelectionInterval(0, 0);
                          // Listener will handle updates to revision display and changes tree
                      } else {
                          // Ensure changes area and revision display are cleared if no commits
                          changesRootNode.removeAllChildren();
                          changesTreeModel.reload();
                          revisionTextLabel.setText("Revision:");
                          revisionIdTextArea.setText("N/A");
                      }
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
              } catch (Exception e) {
                  logger.error("Error fetching commits for branch: " + branchName, e);
                  SwingUtilities.invokeLater(() -> {
                      commitBrowserPanel.setCommits(List.of());
                  });
              }
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
              } catch (Exception e) {
                  logger.error("Error fetching commits for branch: " + branchName, e);
                  SwingUtilities.invokeLater(() -> {
                      commitsTableModel.setRowCount(0);
                      commitsTableModel.addRow(new Object[]{
                              "Error fetching commits: " + e.getMessage(), "", "", ""
                      });
                      changesRootNode.removeAllChildren();
                      changesTreeModel.reload();
                      revisionTextLabel.setText("Revision:");
                      revisionIdTextArea.setText("N/A");
                  });
              }
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
                  SwingUtilities.invokeLater(() -> {
                      if (searchResults.isEmpty()) {
                          commitBrowserPanel.setCommits(List.of());
                          chrome.systemOutput("No commits found matching: " + query);
                          return;
                      }

                      commitBrowserPanel.setCommits(searchResults.stream().map(c -> (ICommitInfo) c).toList());
                      chrome.systemOutput("Found " + searchResults.size() + " commits matching: " + query);
                  });
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
                  SwingUtilities.invokeLater(() -> {
                      commitsTableModel.setRowCount(0);
                      changesRootNode.removeAllChildren();
                      changesTreeModel.reload();

                      if (commitRows.isEmpty()) {
                          revisionTextLabel.setText("Revision:");
                          revisionIdTextArea.setText("N/A");
                          chrome.systemOutput("No commits found matching: " + query);
                          return;
                      }

                      for (Object[] rowData : commitRows) {
                          commitsTableModel.addRow(rowData);
                      }

                      chrome.systemOutput("Found " + commitRows.size() + " commits matching: " + query);
                      if (commitsTableModel.getRowCount() > 0) {
                          // Fit column widths
                          TableUtils.fitColumnWidth(commitsTable, 1); // Author
                          TableUtils.fitColumnWidth(commitsTable, 2); // Date
                          commitsTable.setRowSelectionInterval(0, 0);
                          // Listener will handle updates to revision display and changes tree
                      } else {
                          // Ensure changes area and revision display are cleared if no search results
                          changesRootNode.removeAllChildren();
                          changesTreeModel.reload();
                          revisionTextLabel.setText("Revision:");
                          revisionIdTextArea.setText("N/A");
                      }
                  });
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
              } catch (Exception e) {
                  logger.error("Error searching commits: {}", query, e);
                  SwingUtilities.invokeLater(() -> {
                      chrome.toolErrorRaw("Error searching commits: " + e.getMessage());
                      commitBrowserPanel.setCommits(List.of());
                  });
              }
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
              } catch (Exception e) {
                  logger.error("Error searching commits: {}", query, e);
                  SwingUtilities.invokeLater(() -> {
                      chrome.toolErrorRaw("Error searching commits: " + e.getMessage());
                      revisionTextLabel.setText("Revision:");
                      revisionIdTextArea.setText("N/A");
                  });
              }
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
          // Commit browser panel in the center
          container.add(commitBrowserPanel, BorderLayout.CENTER);
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
          // Commit browser panel in the center
          container.add(commitBrowserPanel, BorderLayout.CENTER);
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java

  <<<<<<<< SEARCH src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
      /**
       * Selects a commit in the commits table by its ID.
       */
      public void selectCommitById(String commitId) {
          commitBrowserPanel.selectCommitById(commitId);
      }
  ======== src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
      /**
       * Selects a commit in the commits table by its ID.
       */
      public void selectCommitById(String commitId) {
          for (int i = 0; i < commitsTableModel.getRowCount(); i++) {
              // Get CommitInfo from hidden column 5
              ICommitInfo commitInfo = (ICommitInfo) commitsTableModel.getValueAt(i, 5);
              if (commitId.equals(commitInfo.id())) {
                  commitsTable.setRowSelectionInterval(i, i);
                  commitsTable.scrollRectToVisible(commitsTable.getCellRect(i, 0, true));
                  // Listener will handle updateChangesForCommits and revisionLabel
                  return;
              }
          }

          // If not found in the current view, let the user know
          chrome.systemOutput("Commit " + commitId.substring(0, 7) + " not found in current branch view");
      }
  >>>>>>>> REPLACE src/main/java/io/github/jbellis/brokk/gui/GitLogTab.java
`;


    function showEditMd() {
        const diffContent = `# Diff of changes

\`\`\`[--- app/src/main/java/io/github/jbellis/brokk/gui/dialogs/analyzer/JavaAnalyzerSettingsPanel.java, +++ app/src/main/java/io/github/jbellis/brokk/gui/dialogs/analyzer/JavaAnalyzerSettingsPanel.java, @@ -31,7 +31,6 @@,  ,      public JavaAnalyzerSettingsPanel(SettingsProjectPanel parent, Language language, Path projectRoot, IConsoleIO io) {,          super(new BorderLayout(), language, projectRoot, io);, -        logger.debug("JavaAnalyzerConfigPanel initialised");,  ,          // Create a panel with GridBagLayout for the actual content,          var contentPanel = new JPanel(new GridBagLayout());]\`\`\``;

        simulateEvent('chunk', {text: contentUser, msgType: 'USER', streaming: false, reasoning: false})
        simulateEvent('chunk', {text: ai, msgType: 'AI', streaming: false, reasoning: false})
        simulateEvent('chunk', {text: diffContent, msgType: 'SYSTEM', streaming: false, reasoning: false})
        //simulateEvent('chunk', {text: "# Now we are finished!", msgType: 'CUSTOM', streaming: false, reasoning: false})
    }

    function streamEdit() {
        const contentUser = `fix it`;

        const contentReasoning = `**Adding AIReasoning Type**

I've been working on implementing the \`AIReasoning\` message type, as we planned.  I've made initial changes in \`frontend-mop/src/types.ts\`, updating the \`BrokkEvent\` and \`Bubble\` types to include it. Next, I'll integrate this with the frontend codebase, ensuring seamless communication of AI-driven reasoning.


**Expanding Data Structures**

I've successfully modified \`frontend-mop/src/types.ts\` to include \`'AIReasoning'\` within both \`BrokkEvent['msgType']\` and \`Bubble['type']\`.  The next steps involve implementing the transient nature of \`AIReasoning\` bubbles in the bubbles store and then the frontend styling and rendering. I'll need to define the purple border color and the loading icon display in the respective files next.


**Adding Transient AI Reasoning**

I'm now integrating transient logic for \`AIReasoning\` bubbles in the bubbles store, specifically within the \`bubblesStore.update\` method for handling \`chunk\` events. The aim is to automatically remove \`AIReasoning\` bubbles when a new non-\`AIReasoning\` chunk is received. I've formulated the necessary conditional logic to implement this behavior, ensuring that these bubbles appear and then promptly disappear when appropriate.


**Defining Transient Behavior**

I'm now focusing on the \`bubblesStore.update\` method, specifically within the 'chunk' case. I'm introducing logic to handle the transient nature of \`AIReasoning\` bubbles. My goal is to automatically remove the last bubble if it's an \`AIReasoning\` bubble and a new non-\`AIReasoning\` chunk arrives, which I believe is an optimal solution. I am formulating the specific conditional logic for this removal to ensure seamless integration and appropriate behavior.


**Refining Transient Logic**

I'm currently working on the transient behavior in \`bubblesStore.update\`.  I've refined the logic for removing \`AIReasoning\` bubbles.  The conditional check is now robust and includes optional chaining to prevent errors. I've also incorporated the correct handling of \`msgType\` to determine when to remove the bubble.  Next, I'll move on to implementing the frontend styling for this new bubble type.


**Defining AIReasoning Logic**

I've outlined the transient logic for \`AIReasoning\` bubbles in the \`bubblesStore.update\` method. I will add this logic at the top of the chunk case to remove the last bubble if it's an \`AIReasoning\` type and the incoming message is not also of type \`AIReasoning\`. I'll be careful to create new lists to avoid unintended mutations and address the initial check.


**Adding AIReasoning Transient Logic**

I'm now implementing the transient logic for \`AIReasoning\` bubbles within \`bubblesStore.update\`. I've added a conditional block to remove the last bubble if it's \`AIReasoning\` and the new chunk is not, ensuring that the bubbles automatically disappear. I've also addressed the edge case of an empty list, ensuring the code functions correctly in all scenarios. I will now integrate the new SEARCH/REPLACE blocks.


**Finalizing AIReasoning Implementation**

I'm now completing the implementation. I've written the \`SEARCH/REPLACE\` blocks for \`frontend-mop/src/types.ts\` and \`frontend-mop/src/stores/bubblesStore.ts\`. I'll integrate the new blocks into these files to finish integrating the new AIReasoning bubble type and its transient behavior. Next, I'll style the bubble and its contents.


**Integrating Transient Logic**

I've completed the initial structure and tests for adding the new \`AIReasoning\` logic. I've successfully implemented the core transient behavior: automatically removing \`AIReasoning\` bubbles when a new message arrives.  Specifically, I've integrated this new behavior into \`bubblesStore.update\`, ensuring proper handling and removal of these bubbles. The conditional check, which handles different scenarios, is in place to determine when to trigger the removal.


**Enhancing AI Bubble Handling**

I've been working on refining the transient behavior of \`AIReasoning\` bubbles. I've successfully implemented the core logic to automatically remove these bubbles under specific conditions, primarily when a new, non-\`AIReasoning\` message arrives. I've also strengthened the conditions to properly manage edge cases and ensure a seamless display. The next steps will involve implementing the styling updates for this new bubble type.
`;

        const contentAi = `I understand the issue with the ordering of buffered events and calls in the JavaScript code, which causes the UI to sometimes clear at the end due to incorrect replay order. The problem stems from having two separate buffers (\`_callQueue\` and \`_eventBuffer\`) and replaying them in the wrong order. I'll fix this by unifying the buffer into a single queue with a sequence number to maintain the correct order of operations during replay.

Here's the plan:
1. Modify the temporary stub in \`index.html\` to use a single buffer with a sequence number.
2. Update the replay logic in \`index.ts\` to process this unified buffer in sequence order.

Here are the *SEARCH/REPLACE* blocks to implement these changes:

<<<<<<< SEARCH frontend-mop/index.html
    // Immediately define brokk with a proxy to buffer all early calls from Java
    (function() {
      const callQueue = []; // Stores {method, args} for all calls except onEvent
      const eventBuffer = []; // Stores payloads for onEvent

      window.brokk = new Proxy({
        _callQueue: callQueue,
        _eventBuffer: eventBuffer
      }, {
        get(target, prop) {
          // Allow direct access to internal queues
          if (prop === '_callQueue' || prop === '_eventBuffer') {
            return target[prop];
          }
          // Return a stub function for any other property access
          return (...args) => {
            if (prop === 'onEvent') {
              console.log('Buffering early event from Java:', JSON.stringify(args));
              eventBuffer.push(...args);
            } else {
              console.log('Buffering early call from Java to', prop);
              callQueue.push({ method: prop, args });
            }
            // Provide default return values for synchronous methods
            if (prop === 'getSelection') {
              return '';
            }
            return undefined;
          };
        }
      });
    })();
=======
    // Immediately define brokk with a proxy to buffer all early calls from Java
    (function() {
      const buffer = []; // Unified buffer for all calls and events
      let seq = 0; // Sequence number to maintain order

      window.brokk = new Proxy({
        _buffer: buffer
      }, {
        get(target, prop) {
          // Allow direct access to internal buffer
          if (prop === '_buffer') {
            return target[prop];
          }
          // Return a stub function for any other property access
          return (...args) => {
            if (prop === 'onEvent') {
              console.log('Buffering early event from Java:', JSON.stringify(args));
              buffer.push({ type: 'event', payload: args[0], seq: seq++ });
            } else {
              console.log('Buffering early call from Java to', prop);
              buffer.push({ type: 'call', method: prop, args: args, seq: seq++ });
            }
            // Provide default return values for synchronous methods
            if (prop === 'getSelection') {
              return '';
            }
            return undefined;
          };
        }
      });
    })();
>>>>>>> REPLACE

\`\`\`
frontend-mop/src/index.ts
<<<<<<< SEARCH
// Retrieve buffered calls and events from the early stub
const pendingCalls = window.brokk._callQueue || [];
const bufferedEvents = window.brokk._eventBuffer || [];

// Replace the temporary brokk proxy with the real implementation
window.brokk = {
  _callQueue: [],
  _eventBuffer: [],
  onEvent: (payload) => {
    console.log('Received event from Java bridge:', JSON.stringify(payload));
    eventStore.set(payload);

    // ACK after a frame render to ensure UI has updated
    if (payload.epoch) {
      requestAnimationFrame(() => {
        if (window.javaBridge) {
          window.javaBridge.onAck(payload.epoch);
        }
      });
    }
  },
  getSelection: () => {
    return window.getSelection()?.toString() ?? '';
  },
  clear: () => {
    eventStore.set({ type: 'chunk', text: '', isNew: true, msgType: 'SYSTEM', epoch: 0 });
  },
  setTheme: (dark, isDevMode, zoom) => {
    themeStore.set(dark);
    if (dark) {
      document.body.classList.add('theme-dark');
    } else {
      document.body.classList.remove('theme-dark');
    }
    if (zoom !== undefined) {
      console.log('[Mock setTheme] Setting zoom:', zoom);
      try {
        localStorage.setItem('brokk.zoom', String(zoom));
      } catch (e) {
        // ignore
      }
    }
  },
  showSpinner: (message) => {
    spinnerStore.set(message);
  }
};

// Process any buffered events first to maintain temporal order
if (bufferedEvents.length > 0) {
  console.log('Replaying', bufferedEvents.length, 'buffered events');
  bufferedEvents.forEach(event => {
    window.brokk.onEvent(event);
  });
}

// Then replay any other buffered method calls
if (pendingCalls.length > 0) {
  console.log('Replaying', pendingCalls.length, 'buffered method calls');
  pendingCalls.forEach(({ method, args }) => {
    console.log('Replaying call to', method, 'with args:', args);
    const brokk = window.brokk as Record<string, (...args: unknown[]) => unknown>;
    if (typeof brokk[method] === 'function') {
      brokk[method](...args);
    } else {
      console.warn('Method', method, 'no longer exists; skipping replay');
    }
  });
}
=======
// Retrieve buffered calls and events from the early stub
const buffer = window.brokk._buffer || [];

// Replace the temporary brokk proxy with the real implementation
window.brokk = {
  _buffer: [],
  onEvent: (payload) => {
    console.log('Received event from Java bridge:', JSON.stringify(payload));
    eventStore.set(payload);

    // ACK after a frame render to ensure UI has updated
    if (payload.epoch) {
      requestAnimationFrame(() => {
        if (window.javaBridge) {
          window.javaBridge.onAck(payload.epoch);
        }
      });
    }
  },
  getSelection: () => {
    return window.getSelection()?.toString() ?? '';
  },
  clear: () => {
    eventStore.set({ type: 'chunk', text: '', isNew: true, msgType: 'SYSTEM', epoch: 0 });
  },
  setTheme: (dark, isDevMode, zoom) => {
    themeStore.set(dark);
    if (dark) {
      document.body.classList.add('theme-dark');
    } else {
      document.body.classList.remove('theme-dark');
    }
    if (zoom !== undefined) {
      console.log('[Mock setTheme] Setting zoom:', zoom);
      try {
        localStorage.setItem('brokk.zoom', String(zoom));
      } catch (e) {
        // ignore
      }
    }
  },
  showSpinner: (message) => {
    spinnerStore.set(message);
  }
};

// Replay buffered calls and events in sequence order
if (buffer.length > 0) {
  console.log('Replaying', buffer.length, 'buffered items');
  buffer.sort((a, b) => a.seq - b.seq).forEach(item => {
    if (item.type === 'event') {
      console.log('Replaying event with epoch:', item.payload.epoch);
      window.brokk.onEvent(item.payload);
    } else {
      console.log('Replaying call to', item.method, 'with args:', item.args);
      const brokk = window.brokk as Record<string, (...args: unknown[]) => unknown>;
      if (typeof brokk[item.method] === 'function') {
        brokk[item.method](...item.args);
      } else {
        console.warn('Method', item.method, 'no longer exists; skipping replay');
      }
    }
  });
}
>>>>>>> REPLACE
\`\`\`
    `;
        let index = 0;
        simulateEvent('clear');
        simulateEvent('chunk', {text: contentUser, msgType: 'USER', streaming: true, reasoning: false});
        const chunks1 = contentReasoning.match(/[\s\S]{1,10}/g) || [];
        const interval1 = setInterval(() => {
            if (index < chunks1.length) {
                simulateEvent('chunk', {text: chunks1[index], msgType: 'AI', streaming: true, reasoning: true});
                index++;
            } else {
                clearInterval(interval1);
                index = 0;
                const chunks = contentAi.match(/[\s\S]{1,10}/g) || [];
                const interval = setInterval(() => {
                    if (index < chunks.length) {
                        simulateEvent('chunk', {text: chunks[index], msgType: 'AI', streaming: true, reasoning: false});
                        index++;
                    } else {
                        clearInterval(interval);
                    }
                }, 10);
            }
        }, 10);
    }


    function setSearchFromInput() {
        const queryInput = document.getElementById('search-query-input');
        const caseSensitiveCheckbox = document.getElementById('search-case-sensitive');
        if (queryInput && caseSensitiveCheckbox) {
            const query = queryInput.value;
            const caseSensitive = caseSensitiveCheckbox.checked;
            window.brokk.setSearch(query, caseSensitive);
        }
    }

    function getSearchStateAndDisplay() {
        const state = window.brokk.getSearchState();
        const stateDisplay = document.getElementById('search-state-display');
        if (stateDisplay && state) {
            stateDisplay.textContent = `Total: ${state.total}, Current: ${state.current}, Query: '${state.query}', Case Sensitive: ${state.caseSensitive}`;
        }
    }

    // Symbol testing functions
    function showSymbolTestContent() {
        const content = `# Symbol Lookup Test Cases

## Java Symbols (Should be highlighted)
Common classes: \`String\`, \`List\`, \`Map\`, \`ArrayList\`, \`HashMap\`, \`Set\`
Methods: \`toString\`, \`size\`, \`add\`, \`get\`, \`put\`, \`remove\`, \`contains\`
Core: \`Object\`, \`Class\`, \`Exception\`, \`Thread\`

## **NEW: Partial Match Tests (Should be highlighted with dotted underline and ‚ó¶ indicator)**
Java method references: \`List.add\`, \`String.toString\`, \`Map.put\`, \`ArrayList.size\`, \`HashMap.get\`
More examples: \`Set.contains\`, \`Object.toString\`, \`Collection.isEmpty\`, \`Thread.run\`

**Complex Method Calls with Parameters:**
\`SwingUtil.runOnEdt(task)\`, \`SwingUtilities.invokeLater(...)\`, \`EventQueue.invokeAndWait(runnable)\`, \`JOptionPane.showMessageDialog(...)\`

**Note:** Partial matches like \`List.add\` should:
1. Have dotted underlines (not solid)
2. Show a small ‚ó¶ indicator after the text
3. Have dashed borders (not solid)
4. When clicked, navigate to the \`List\` class, not the method

## Python Symbols (Should be highlighted)
Built-ins: \`list\`, \`dict\`, \`str\`, \`int\`, \`float\`, \`bool\`, \`len\`, \`range\`
Methods: \`append\`, \`keys\`, \`values\`, \`items\`, \`pop\`, \`extend\`, \`join\`
Functions: \`print\`, \`input\`, \`open\`, \`close\`, \`read\`, \`write\`

## JavaScript Symbols (Should be highlighted)
Keywords: \`var\`, \`let\`, \`const\`, \`function\`, \`class\`, \`interface\`, \`async\`, \`await\`
Built-ins: \`Array\`, \`Object\`, \`Promise\`, \`console\`, \`document\`, \`window\`

## Programming Terms (Should be highlighted)
Concepts: \`parser\`, \`lexer\`, \`token\`, \`node\`, \`tree\`, \`visitor\`
Patterns: \`handler\`, \`callback\`, \`iterator\`, \`stream\`, \`buffer\`

## File Path Test Cases (Should be highlighted if they exist)
Basic files: \`src/main/App.java\`, \`package.json\`, \`README.md\`, \`index.html\`, \`dev.html\`
With line numbers: \`App.java:25\`, \`package.json:15-20\`, \`main.py:42\`, \`index.ts:100\`
Nested paths: \`src/components/Button.tsx\`, \`tests/unit/parser.test.js\`, \`frontend-mop/src/index.ts\`
Project files: \`vite.config.mjs\`, \`tsconfig.json\`, \`build.gradle\`, \`pom.xml\`

## File Path vs Symbol Test (Should NOT be highlighted - fake files)
Fake files: \`src/fake/Missing.java\`, \`nonexistent.json\`, \`invalid/path.ts\`
Invalid formats: \`NoExtension\`, \`justtext\`, \`not.a.real.extension\`

## Unknown Symbols (Should NOT be highlighted)
These should appear normal: \`fakeSymbol\`, \`nonExistent\`, \`madeUpClass\`, \`bogusMethod\`
Invalid partials: \`FakeClass.method\`, \`NotReal.function\`, \`missing.call\`

## Mixed Test
Real: \`String\` and \`List\` and \`parser\` vs Fake: \`NotReal\` and \`Missing\` and \`invalid\`
Partial vs Exact: \`List\` (exact, solid underline) vs \`List.add\` (partial, dotted underline + ‚ó¶)
Files vs Symbols: \`package.json\` (file) vs \`String\` (symbol) - different highlighting styles

**Instructions:**
- Exact matches: solid underlines, solid borders
- Partial matches: dotted underlines, dashed borders, ‚ó¶ indicator
- File paths: file-specific highlighting with context menu on click
- Click to test interactions!`;

        window.brokk.clear();
        simulateEvent('chunk', {
            text: content,
            msgType: 'AI',
            streaming: false
        });
    }

    function streamSymbolTestContent() {
        const content = `# Streaming Symbol Lookup Test

## Java Symbols (Should be highlighted progressively)
Common classes: \`String\`, \`List\`, \`Map\`, \`ArrayList\`, \`HashMap\`, \`Set\`
Methods: \`toString\`, \`size\`, \`add\`, \`get\`, \`put\`, \`remove\`, \`contains\`
Core: \`Object\`, \`Class\`, \`Exception\`, \`Thread\`

## **NEW: Partial Matches During Streaming**
Method references: \`List.add\`, \`String.toString\`, \`Map.put\`, \`ArrayList.size\`
More examples: \`Set.contains\`, \`Object.toString\`, \`HashMap.get\`
Complex patterns: \`SwingUtil.runOnEdt(task)\`, \`SwingUtilities.invokeLater(...)\`

## Python Symbols (Should be highlighted progressively)
Built-ins: \`list\`, \`dict\`, \`str\`, \`int\`, \`float\`, \`bool\`, \`len\`, \`range\`
Methods: \`append\`, \`keys\`, \`values\`, \`items\`, \`pop\`, \`extend\`, \`join\`
Functions: \`print\`, \`input\`, \`open\`, \`close\`, \`read\`, \`write\`

## JavaScript Symbols (Should be highlighted progressively)
Keywords: \`var\`, \`let\`, \`const\`, \`function\`, \`class\`, \`interface\`, \`async\`, \`await\`
Built-ins: \`Array\`, \`Object\`, \`Promise\`, \`console\`, \`document\`, \`window\`

## Programming Terms (Should be highlighted progressively)
Concepts: \`parser\`, \`lexer\`, \`token\`, \`node\`, \`tree\`, \`visitor\`
Patterns: \`handler\`, \`callback\`, \`iterator\`, \`stream\`, \`buffer\`

## Mixed Test - Streaming
Real: \`String\` and \`List\` and \`parser\` vs Fake: \`NotReal\` and \`Missing\` and \`invalid\`
Partial vs Exact: \`List\` vs \`List.add\` (watch for different styling!)

**Instructions:** This tests the throttled symbol resolution during streaming. Symbols should appear unhighlighted first, then get highlighted in batches as the streaming throttle processes them! Partial matches should get dotted underlines + ‚ó¶ indicators.`;

        window.brokk.clear();

        // Split content into chunks and stream them with delays
        const chunks = content.match(/[\s\S]{1,50}/g) || [];
        let index = 0;

        const streamInterval = setInterval(() => {
            if (index < chunks.length) {
                simulateEvent('chunk', {
                    text: chunks[index],
                    msgType: 'AI',
                    streaming: true
                });
                index++;
            } else {
                clearInterval(streamInterval);
                console.log('[Dev] Streaming symbol test completed - should see throttled symbol resolution');
            }
        }, 50); // 50ms between chunks to simulate real streaming
    }

    function showPartialMatchTest() {
        const testContent = `
# Partial Symbol Matching Test Cases

## Java Method References (Should highlight class part only)
- \`List.add\` - should highlight "List"
- \`String.toString\` - should highlight "String"
- \`Map.put\` - should highlight "Map"
- \`ArrayList.get\` - should highlight "ArrayList"
- \`StringBuilder.append\` - should highlight "StringBuilder"

## Nested Class References
- \`Collections.emptyList\` - should highlight "Collections"
- \`System.currentTimeMillis\` - should highlight "System"

## Full Class Names (Should highlight entire text)
- \`ArrayList\` - should highlight "ArrayList"
- \`String\` - should highlight "String"
- \`HashMap\` - should highlight "HashMap"

## Invalid Cases (Should not highlight)
- \`myMethod\` - lowercase method name
- \`list.add\` - lowercase class name
- \`add\` - standalone method name
- \`123invalid\` - starts with number

## Multi-Range Test (Future)
When backend supports multiple ranges:
- \`Package.Class.method\` - could highlight both "Package" and "Class"
`;

        window.brokk.clear();
        simulateEvent('chunk', { text: "Testing partial symbol matching with mock data...", msgType: 'USER', streaming: false });
        simulateEvent('chunk', { text: testContent, msgType: 'AI', streaming: false });
    }



    function listMockSymbols() {
        const symbols = Array.from(window.javaBridge?._mockSymbolsSet || []).sort();
        const symbolList = symbols.map(s => `- \`${s}\``).join('\n');
        const content = `# Mock Symbol Database (${symbols.length} symbols)

## All Available Symbols:
${symbolList}

## Usage:
These symbols will be highlighted when they appear in inline code blocks.
Symbols get the \`.symbol-exists\` CSS class which adds:
- Underline decoration
- Pointer cursor on hover
- Light blue background on hover

**Test it:** Try typing some of these symbols in the markdown playground below!`;

        window.brokk.clear();
        simulateEvent('chunk', { text: content, msgType: 'AI', streaming: false });
    }

    // Update symbol count display
    function updateSymbolCount() {
        const count = window.javaBridge?._mockSymbolsSet?.size || 0;
        const symbolCountEl = document.getElementById('symbol-count');
        if (symbolCountEl) {
            symbolCountEl.textContent = count;
        }
    }

    // Ensure functions are available globally for onclick handlers
    window.showSymbolTestContent = showSymbolTestContent;
    window.streamSymbolTestContent = streamSymbolTestContent;
    window.showPartialMatchTest = showPartialMatchTest;
    window.listMockSymbols = listMockSymbols;
    window.updateSymbolCount = updateSymbolCount;

    (function () {
        const mdInput = document.getElementById('md-playground');
        let rafId = 0;

        mdInput.addEventListener('input', () => {
            cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(() => {
                window.brokk.clear();
                simulateEvent('chunk', {
                    text: mdInput.value,
                    msgType: 'AI',
                    streaming: true
                });
            });
        });

        // Initialize search state display and symbol count on load
        getSearchStateAndDisplay();
        updateSymbolCount();
    })();

// ----- Code wrap helpers and demo ---------------------------------------------------------

function getWrapMode() {
    return document.documentElement.classList.contains('code-wrap-mode') ? 'wrap' : 'scroll';
}

function updateWrapModeStatus() {
    var el = document.getElementById('wrap-mode-status');
    if (el) {
        el.textContent = '(' + getWrapMode() + ')';
    }
}

function setWrapMode(mode) {
    if (mode !== 'wrap' && mode !== 'scroll') return;
    document.documentElement.classList.toggle('code-wrap-mode', mode === 'wrap');
    document.documentElement.classList.toggle('code-scroll-mode', mode === 'scroll');
    updateWrapModeStatus();
}

function toggleCodeWrap() {
    setWrapMode(getWrapMode() === 'wrap' ? 'scroll' : 'wrap');
    updateModeIndicators();
}

// Update all mode indicators in the rendered content
function updateModeIndicators() {
    // Check if we have the demo content currently displayed
    const mopRoot = document.getElementById('mop-root');
    if (mopRoot && mopRoot.textContent.includes('Code Block Modes Demo')) {
        // Automatically regenerate the demo content with updated indicators
        showAllCodeblockCases();
    }
}

// Initialize default mode if missing and update status
(function () {
    if (!document.documentElement.classList.contains('code-wrap-mode') && !document.documentElement.classList.contains('code-scroll-mode')) {
        document.documentElement.classList.add('code-scroll-mode');
    }
    updateWrapModeStatus();
})();

// Show a comprehensive sample covering all code block cases
function showAllCodeblockCases() {
    const mode = getWrapMode();
    const content = `# Code Block Modes Demo

Current mode: \`${mode}\`

## 1. Fenced (language tag: java) [${mode}]
\`\`\`java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello from fenced java block!");
    }
}
\`\`\`

## 2. Fenced (language tag: diff) [${mode}]
\`\`\`diff
- System.out.println("old");
+ System.out.println("new");
\`\`\`

## 3. Fenced (no language) [${mode}]
\`\`\`
SELECT * FROM users WHERE id = 42;
-- No language tag on this code fence
\`\`\`

## 4. Indented code block (4 spaces) [${mode}]
    # Indented code starts with 4 spaces
    def add(a, b):
        return a + b

    print(add(2, 3))

## 5. Raw HTML pre/code (language: python) [${mode}]
<pre><code class="language-python">def greet(name):
    print("Hello, " + name + "!")
greet("World")</code></pre>

## 6. Very long single line to test wrap vs. scroll [${mode}]
\`\`\`text
ThisIsAReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyLongTokenThatShouldForceHorizontalScrollingOrWrappingDependingOnTheCurrentModeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
\`\`\`

## 7. Another fenced block (language: javascript) [${mode}]
\`\`\`javascript
const nums = [1,2,3,4];
const doubled = nums.map(n => n * 2);
console.log("Doubled:", doubled);
\`\`\`

## 8. Custom Edit Block - Unfenced (with filename) [${mode}]
<<<<<<< SEARCH Example.java
public void oldMethod() {
    System.out.println("This is the old implementation with a very long line that should demonstrate wrapping behavior when code block mode is set to wrap instead of scroll mode");
}
=======
public void newMethod() {
    System.out.println("This is the new implementation");
    System.out.println("With multiple lines");
    System.out.println("And another extremely long line to test how the word wrapping works in edit blocks when the mode is toggled between wrap and scroll modes");
}
>>>>>>> REPLACE

## 9. Custom Edit Block - Fenced (with filename) [${mode}]
\`\`\`
Calculator.java
<<<<<<< SEARCH
int calculate(int a, int b) {
    return a + b; // Simple addition with a really long comment that goes on and on to test horizontal scrolling versus word wrapping in custom edit blocks
}
=======
int calculate(int a, int b) {
    // Enhanced calculation with validation
    if (a < 0 || b < 0) {
        throw new IllegalArgumentException("Negative numbers not allowed in this context and this message is intentionally long");
    }
    return a + b;
}
>>>>>>> REPLACE
\`\`\`

## 10. Custom Edit Block - No filename [${mode}]
<<<<<<< SEARCH
const oldFunction = () => {
    console.log("Old implementation with extremely long variable names and method calls that should test the horizontal scrolling versus word wrapping functionality");
}
=======
const newFunction = () => {
    console.log("New implementation");
    console.log("With better structure");
    console.log("And this very long log message to demonstrate how word wrapping affects custom edit blocks");
}
>>>>>>> REPLACE
`;

    window.brokk.clear();
    simulateEvent('chunk', { text: content, msgType: 'AI', streaming: false });
}

</script>
<div id="mop-root"></div>
</body>
</html>
